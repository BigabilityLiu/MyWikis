# 2 基础知识

## 2.4 算法和数据操作

## 2.4.3 位运算

|        | 0 0  | 1 0  | 1 1  |
| ------ | ---- | ---- | ---- |
| 与&    | 0    | 0    | 1    |
| 或 \|  | 0    | 1    | 1    |
| 异或 ^ | 0    | 1    | 0    |

**右移运算符**m>>n表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。但右移时处理最左边位的情形要稍微复杂一点。如果数字是一个无符号数值，则用0填补最左边的n位。如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。也就是说如果数字原先是一个正数，则右移之后在最左边补n个0；如果数字原先是负数，则右移之后在最左边补n个1。下面是对两个8位有符号数作右移的例子：

00001010>>2=00000010 

10001010>>3=11110001

# 3 高质量的代码

## 3.3代码的完整性

在编码之前要考虑单元测试。通常我们可以从功能测试、边界测试和负面测试三方面设计测试用例，以确保代码的完整性。

面试题11：数值的整数次方 题目：实现函数double Power（double base, int exponent），求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

知识点：

1. 异常报错（base 和 exponent 都为0的情况）
2. exponent为负数情况 
3. double 比较大小应该为abs(a-b)<0.0000001